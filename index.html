<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Artist Portfolio</title>
    <style>
        @import url("https://fonts.cdnfonts.com/css/pp-neue-montreal");
        
        @font-face {
            font-family: "PPSupplyMono";
            src: url("https://assets.codepen.io/7558/PPSupplyMono-Regular.ttf") format("truetype");
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        :root {
            --font-mono: "PPSupplyMono", monospace;
            --font-sans: "PP Neue Montreal", sans-serif;
            --color-bg: #000;
            --color-text: #fff;
            --color-text-muted: rgba(255, 255, 255, 0.8);
            --color-text-light: rgba(255, 255, 255, 0.6);
            --color-accent: #fff;
            --font-size-mono: clamp(10px, 1.2vw, 12px);
            --spacing-sm: 1rem;
            --spacing-md: 2rem;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-sans);
            background: var(--color-bg);
            overflow: hidden;
            color: var(--color-text);
            cursor: pointer;
        }

        a { color: inherit; text-decoration: none; }

        .slider-wrapper {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            opacity: 0;
            transition: opacity 1.5s ease-in;
            pointer-events: none;
        }

        .slider-wrapper.loaded {
            opacity: 1;
            pointer-events: auto;
        }

        .webgl-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- Content Overlay --- */
        .content-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 2;
            pointer-events: none;
            width: 80%;
            max-width: 800px;
            mix-blend-mode: exclusion;
        }

        .content-heading {
            font-size: clamp(3rem, 8vw, 6rem);
            font-weight: 300;
            margin-bottom: 1rem;
            line-height: 1;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.8s ease, transform 0.8s ease;
        }

        .content-description {
            font-family: var(--font-mono);
            font-size: clamp(0.9rem, 1.5vw, 1.1rem);
            line-height: 1.6;
            color: var(--color-text-muted);
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.8s ease 0.1s, transform 0.8s ease 0.1s;
            white-space: pre-line; /* 줄바꿈 허용 */
        }

        .content-active .content-heading,
        .content-active .content-description {
            opacity: 1;
            transform: translateY(0);
        }

        /* UI Elements */
        .slide-number {
            position: absolute;
            top: 50%;
            left: var(--spacing-md);
            transform: translateY(-50%);
            font-family: var(--font-mono);
            font-size: 12px;
            font-weight: 600;
            color: var(--color-text);
            z-index: 3;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .slide-total {
            position: absolute;
            top: 50%;
            right: var(--spacing-md);
            transform: translateY(-50%);
            font-family: var(--font-mono);
            font-size: 12px;
            font-weight: 600;
            color: var(--color-text);
            z-index: 3;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .slides-navigation {
            position: absolute;
            bottom: var(--spacing-md);
            left: var(--spacing-md);
            right: var(--spacing-md);
            display: flex;
            gap: 0;
            z-index: 3;
            pointer-events: all;
        }

        .slide-nav-item {
            display: flex;
            flex-direction: column;
            cursor: pointer;
            padding: var(--spacing-sm);
            flex: 1;
            border: none;
            background: none;
        }

        .slide-progress-line {
            width: 100%;
            height: 2px;
            background: rgba(255, 255, 255, 0.2);
            margin-bottom: 8px;
            border-radius: 1px;
            overflow: hidden;
        }

        .slide-progress-fill {
            height: 100%;
            width: 0%;
            background: var(--color-accent);
            transition: width 0.1s ease, opacity 0.3s ease;
            border-radius: 1px;
        }

        .slide-nav-title {
            font-family: var(--font-mono);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--color-text-muted);
            font-weight: 600;
            transition: color 0.3s ease;
            text-align: left;
        }

        .slide-nav-item.active .slide-nav-title {
            color: var(--color-text);
        }

        .help-text {
            position: absolute;
            top: var(--spacing-md);
            left: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 11px;
            text-transform: uppercase;
            color: var(--color-text-muted);
            z-index: 3;
        }

        /* Tweakpane Styling */
        .tp-dfwv {
            position: fixed !important;
            top: 20px !important;
            right: 20px !important;
            z-index: 1000 !important;
            max-width: 320px !important;
            background: rgba(0, 0, 0, 0.9) !important;
            backdrop-filter: blur(20px) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            border-radius: 8px !important;
        }

        @media (max-width: 600px) {
            .slides-navigation { bottom: var(--spacing-sm); left: var(--spacing-sm); right: var(--spacing-sm); }
            .slide-nav-item { padding: 0.75rem; }
            .help-text { top: var(--spacing-sm); left: var(--spacing-sm); }
            .slide-number { left: var(--spacing-sm); }
            .slide-total { right: var(--spacing-sm); }
            .content-heading { font-size: 2.5rem; }
        }
    </style>
</head>
<body>

    <main class="slider-wrapper">
        <canvas class="webgl-canvas"></canvas>
        
        <div class="content-overlay" id="contentOverlay">
            <h1 class="content-heading" id="mainHeading">ARTIST NAME</h1>
            <p class="content-description" id="mainDesc">Visual & Auditory Experience</p>
        </div>

        <span class="slide-number" id="slideNumber">01</span>
        <span class="slide-total" id="slideTotal">05</span>
        <span class="help-text">
            H: Toggle Settings • Space/→: Next • ←: Previous
        </span>
        <nav class="slides-navigation" id="slidesNav">
            </nav>
    </main>

    <script type="module">
        import * as THREE from "https://esm.sh/three";
        import { Pane } from "https://cdn.skypack.dev/tweakpane@4.0.4";
        import gsap from "https://esm.sh/gsap"; 

        // ========================================
        // DATA CONFIGURATION
        // ========================================
        const slides = [
            {
                navTitle: "HOME",
                heading: "YOUR NAME",
                description: "Welcome to my official portfolio.",
                media: "https://assets.codepen.io/7558/orange-portrait-001.jpg" // Home은 기본 이미지
            },
            {
                navTitle: "PROFILE",
                heading: "PROFILE",
                description: "I am a visual artist and musician based in Seoul.\nExploring the boundaries between sight and sound.",
                media: "./images/프로필 1.JPG" // [사용자 요청] 로컬 이미지 적용
            },
            {
                navTitle: "MUSIC",
                heading: "DISCOGRAPHY",
                description: "Latest Release: 'Midnight Dreams' (2024)\nAvailable on Spotify, Apple Music, and SoundCloud.",
                media: "https://assets.codepen.io/7558/orange-portrait-003.jpg"
            },
            {
                navTitle: "DEMO",
                heading: "UNRELEASED",
                description: "Experimental sketches and demos.\nExclusive preview of upcoming tracks.",
                media: "https://assets.codepen.io/7558/orange-portrait-004.jpg"
            },
            {
                navTitle: "CONTACT",
                heading: "GET IN TOUCH",
                description: "Booking & Inquiries: email@address.com\nInstagram: @your_handle",
                media: "https://assets.codepen.io/7558/orange-portrait-005.jpg"
            }
        ];

        // ========================================
        // PRELOADER
        // ========================================
        class SliderLoadingManager {
            constructor() {
                this.overlay = null;
                this.canvas = null;
                this.ctx = null;
                this.animationId = null;
                this.startTime = null;
                this.duration = 2000;
                this.createLoadingScreen();
            }
            createLoadingScreen() {
                this.overlay = document.createElement("div");
                this.overlay.style.cssText = `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; justify-content: center; align-items: center; z-index: 10000;`;
                this.canvas = document.createElement("canvas");
                this.canvas.width = 300; this.canvas.height = 300;
                this.ctx = this.canvas.getContext("2d");
                this.overlay.appendChild(this.canvas);
                document.body.appendChild(this.overlay);
                this.startAnimation();
            }
            startAnimation() {
                const centerX = 150, centerY = 150;
                let time = 0, lastTime = 0;
                const animate = (timestamp) => {
                    if (!this.startTime) this.startTime = timestamp;
                    if (!lastTime) lastTime = timestamp;
                    const deltaTime = timestamp - lastTime;
                    lastTime = timestamp;
                    time += deltaTime * 0.001;
                    this.ctx.clearRect(0, 0, 300, 300);
                    this.ctx.fillStyle = "#fff";
                    this.ctx.beginPath();
                    this.ctx.arc(centerX + Math.sin(time*5)*20, centerY, 5, 0, Math.PI*2);
                    this.ctx.fill();
                    
                    if (timestamp - this.startTime >= this.duration) {
                        this.complete();
                        return;
                    }
                    this.animationId = requestAnimationFrame(animate);
                };
                this.animationId = requestAnimationFrame(animate);
            }
            complete() {
                cancelAnimationFrame(this.animationId);
                if (this.overlay) {
                    this.overlay.style.opacity = "0";
                    this.overlay.style.transition = "opacity 0.8s ease";
                    setTimeout(() => {
                        this.overlay?.remove();
                        const sliderWrapper = document.querySelector(".slider-wrapper");
                        if (sliderWrapper) sliderWrapper.classList.add("loaded");
                        setTimeout(() => document.getElementById("contentOverlay").classList.add("content-active"), 500);
                    }, 800);
                }
            }
        }
        document.addEventListener("DOMContentLoaded", () => new SliderLoadingManager());

        // ========================================
        // CONFIG
        // ========================================
        const SLIDER_CONFIG = {
            settings: {
                transitionDuration: 2.5,
                autoSlideSpeed: 6000,
                currentEffect: "glass",
                distortionStrength: 1.0
            }
        };

        // ========================================
        // MAIN LOGIC
        // ========================================
        let currentSlideIndex = 0;
        let isTransitioning = false;
        let shaderMaterial, renderer, scene, camera;
        let slideTextures = [];
        let texturesLoaded = false;
        let autoSlideTimer = null;
        let progressAnimation = null;
        let sliderEnabled = false;
        let pane = null;

        const SLIDE_DURATION = () => SLIDER_CONFIG.settings.autoSlideSpeed;
        const PROGRESS_UPDATE_INTERVAL = 50;
        const TRANSITION_DURATION = () => SLIDER_CONFIG.settings.transitionDuration;

        let touchStartX = 0;
        let touchEndX = 0;

        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            uniform sampler2D uTexture1;
            uniform sampler2D uTexture2;
            uniform float uProgress;
            uniform vec2 uResolution;
            uniform vec2 uTexture1Size;
            uniform vec2 uTexture2Size;
            uniform float uDistortionStrength;
            
            varying vec2 vUv;

            vec2 getCoverUV(vec2 uv, vec2 textureSize) {
                vec2 s = uResolution / textureSize;
                float scale = max(s.x, s.y);
                vec2 scaledSize = textureSize * scale;
                vec2 offset = (uResolution - scaledSize) * 0.5;
                return (uv * uResolution - offset) / scaledSize;
            }

            void main() {
                vec2 uv1 = getCoverUV(vUv, uTexture1Size);
                vec2 uv2 = getCoverUV(vUv, uTexture2Size);
                
                float progress = uProgress;
                
                // Simple glass/liquid distortion
                vec2 distortion = vec2(
                    sin(vUv.y * 10.0 + progress * 5.0) * 0.05,
                    cos(vUv.x * 10.0 + progress * 5.0) * 0.05
                ) * sin(progress * 3.14) * uDistortionStrength;

                vec4 tex1 = texture2D(uTexture1, uv1 + distortion);
                vec4 tex2 = texture2D(uTexture2, uv2 + distortion);
                
                gl_FragColor = mix(tex1, tex2, progress);
            }
        `;

        const setupPane = () => {
            pane = new Pane({ title: "Visual Controls" });
            pane.addBinding(SLIDER_CONFIG.settings, "distortionStrength", { min: 0, max: 3, label: "Distortion" });
            pane.addBinding(SLIDER_CONFIG.settings, "autoSlideSpeed", { min: 2000, max: 10000, label: "Speed" });
            // Hide pane by default
            const paneEl = document.querySelector(".tp-dfwv");
            if(paneEl) paneEl.style.display = "none";
        };

        const createSlidesNavigation = () => {
            const navContainer = document.getElementById("slidesNav");
            navContainer.innerHTML = "";
            slides.forEach((slide, index) => {
                const navItem = document.createElement("div");
                navItem.className = `slide-nav-item ${index === 0 ? "active" : ""}`;
                navItem.dataset.slideIndex = index;
                navItem.innerHTML = `
                  <div class="slide-progress-line">
                    <div class="slide-progress-fill" style="width: 0%"></div>
                  </div>
                  <div class="slide-nav-title">${slide.navTitle}</div>
                `;
                navItem.addEventListener("click", (e) => {
                    e.stopPropagation();
                    const targetIndex = parseInt(navItem.dataset.slideIndex);
                    if (targetIndex !== currentSlideIndex && !isTransitioning) {
                        navigateToSlide(targetIndex);
                    }
                });
                navContainer.appendChild(navItem);
            });
        };

        const updateNavigationState = (activeIndex) => {
            const navItems = document.querySelectorAll(".slide-nav-item");
            navItems.forEach((item, index) => {
                item.classList.toggle("active", index === activeIndex);
            });
        };

        const updateSlideProgress = (slideIndex, progress) => {
            const navItems = document.querySelectorAll(".slide-nav-item");
            if (navItems[slideIndex]) {
                const progressFill = navItems[slideIndex].querySelector(".slide-progress-fill");
                progressFill.style.width = `${progress}%`;
                progressFill.style.opacity = "1";
            }
        };

        const quickResetProgress = (slideIndex) => {
            const navItems = document.querySelectorAll(".slide-nav-item");
            if (navItems[slideIndex]) {
                const progressFill = navItems[slideIndex].querySelector(".slide-progress-fill");
                progressFill.style.transition = "width 0.2s ease-out";
                progressFill.style.width = "0%";
                setTimeout(() => {
                    progressFill.style.transition = "width 0.1s ease, opacity 0.3s ease";
                }, 200);
            }
        };

        const updateCounter = (index) => {
            document.getElementById("slideNumber").textContent = String(index + 1).padStart(2, "0");
            document.getElementById("slideTotal").textContent = String(slides.length).padStart(2, "0");
        };

        const updateContentOverlay = (index) => {
            const overlay = document.getElementById("contentOverlay");
            const heading = document.getElementById("mainHeading");
            const desc = document.getElementById("mainDesc");

            overlay.classList.remove("content-active");

            setTimeout(() => {
                heading.innerText = slides[index].heading;
                desc.innerText = slides[index].description;
                overlay.classList.add("content-active");
            }, 800); 
        };

        const startAutoSlideTimer = () => {
            if (!texturesLoaded || !sliderEnabled || slideTextures.length < 2) return;
            stopAutoSlideTimer();
            let progress = 0;
            const increment = (100 / SLIDE_DURATION()) * PROGRESS_UPDATE_INTERVAL;
            progressAnimation = setInterval(() => {
                if (!sliderEnabled) { stopAutoSlideTimer(); return; }
                progress += increment;
                updateSlideProgress(currentSlideIndex, progress);
                if (progress >= 100) {
                    clearInterval(progressAnimation);
                    progressAnimation = null;
                    if (!isTransitioning) handleSlideChange();
                }
            }, PROGRESS_UPDATE_INTERVAL);
        };

        const stopAutoSlideTimer = () => {
            if (progressAnimation) clearInterval(progressAnimation);
            if (autoSlideTimer) clearTimeout(autoSlideTimer);
        };

        const safeStartTimer = (delay = 0) => {
            stopAutoSlideTimer();
            if (sliderEnabled && texturesLoaded) {
                if (delay > 0) {
                    autoSlideTimer = setTimeout(() => {
                        if (sliderEnabled) startAutoSlideTimer();
                    }, delay);
                } else {
                    startAutoSlideTimer();
                }
            }
        };

        const navigateToSlide = (targetIndex) => {
            if (isTransitioning || targetIndex === currentSlideIndex) return;
            stopAutoSlideTimer();
            quickResetProgress(currentSlideIndex);
            
            const currentTexture = slideTextures[currentSlideIndex];
            const targetTexture = slideTextures[targetIndex];
            if (!currentTexture || !targetTexture) return;
            
            isTransitioning = true;
            shaderMaterial.uniforms.uTexture1.value = currentTexture;
            shaderMaterial.uniforms.uTexture2.value = targetTexture;
            shaderMaterial.uniforms.uTexture1Size.value = currentTexture.userData.size;
            shaderMaterial.uniforms.uTexture2Size.value = targetTexture.userData.size;
            
            currentSlideIndex = targetIndex;
            updateCounter(currentSlideIndex);
            updateNavigationState(currentSlideIndex);
            updateContentOverlay(currentSlideIndex);

            gsap.fromTo(shaderMaterial.uniforms.uProgress, 
                { value: 0 },
                {
                    value: 1,
                    duration: TRANSITION_DURATION(),
                    ease: "power2.inOut",
                    onComplete: () => {
                        shaderMaterial.uniforms.uProgress.value = 0;
                        shaderMaterial.uniforms.uTexture1.value = targetTexture;
                        isTransitioning = false;
                        safeStartTimer(100);
                    }
                }
            );
        };

        const handleSlideChange = () => {
            if (isTransitioning || !texturesLoaded || !sliderEnabled) return;
            const nextIndex = (currentSlideIndex + 1) % slides.length;
            navigateToSlide(nextIndex);
        };

        const loadImageTexture = (src) => {
            return new Promise((resolve, reject) => {
                const loader = new THREE.TextureLoader();
                loader.load(src, (texture) => {
                    texture.minFilter = THREE.LinearFilter;
                    texture.userData = { size: new THREE.Vector2(texture.image.width, texture.image.height) };
                    resolve(texture);
                }, undefined, (err) => {
                    console.error("Texture Load Error:", src, err);
                    reject(err);
                });
            });
        };

        const initializeRenderer = async () => {
            const canvas = document.querySelector(".webgl-canvas");
            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            renderer = new THREE.WebGLRenderer({ canvas, antialias: false, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            shaderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uTexture1: { value: null },
                    uTexture2: { value: null },
                    uProgress: { value: 0.0 },
                    uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    uTexture1Size: { value: new THREE.Vector2(1, 1) },
                    uTexture2Size: { value: new THREE.Vector2(1, 1) },
                    uDistortionStrength: { value: SLIDER_CONFIG.settings.distortionStrength }
                },
                vertexShader,
                fragmentShader
            });

            scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), shaderMaterial));

            for (let i = 0; i < slides.length; i++) {
                try {
                    const texture = await loadImageTexture(slides[i].media);
                    slideTextures.push(texture);
                } catch (error) { 
                    console.warn(`Failed to load image ${i}: ${slides[i].media}`); 
                }
            }

            if (slideTextures.length >= 2) {
                shaderMaterial.uniforms.uTexture1.value = slideTextures[0];
                shaderMaterial.uniforms.uTexture2.value = slideTextures[1];
                shaderMaterial.uniforms.uTexture1Size.value = slideTextures[0].userData.size;
                shaderMaterial.uniforms.uTexture2Size.value = slideTextures[1].userData.size;
                texturesLoaded = true;
                sliderEnabled = true;
                safeStartTimer(500);
            }

            const render = () => {
                requestAnimationFrame(render);
                renderer.render(scene, camera);
            };
            render();
        };

        window.addEventListener("load", async () => {
            createSlidesNavigation();
            updateCounter(0);
            setupPane();
            await initializeRenderer();
        });

        document.addEventListener("click", (e) => {
            if (e.target.closest(".slides-navigation")) return;
            if (!isTransitioning && sliderEnabled) {
                stopAutoSlideTimer();
                quickResetProgress(currentSlideIndex);
                handleSlideChange();
            }
        });

        window.addEventListener("resize", () => {
            if (renderer && shaderMaterial) {
                renderer.setSize(window.innerWidth, window.innerHeight);
                shaderMaterial.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
            }
        });

        document.addEventListener("keydown", (e) => {
            if (e.code === "Space" || e.code === "ArrowRight") {
                if (!isTransitioning && sliderEnabled) {
                    stopAutoSlideTimer();
                    quickResetProgress(currentSlideIndex);
                    handleSlideChange();
                }
            } else if (e.code === "ArrowLeft") {
                if (!isTransitioning && sliderEnabled) {
                    stopAutoSlideTimer();
                    quickResetProgress(currentSlideIndex);
                    const prevIndex = (currentSlideIndex - 1 + slides.length) % slides.length;
                    navigateToSlide(prevIndex);
                }
            } else if (e.code === "KeyH") {
                const paneElement = document.querySelector(".tp-dfwv");
                if (paneElement) paneElement.style.display = paneElement.style.display === "none" ? "block" : "none";
            }
        });
    </script>
</body>
</html>
